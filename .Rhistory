# while (target(x + b) >= target(x) * y) {
#   b <- 2 * b
# }
return(matrix(c(x - a, x + a), d))
}
x <- MCMC(target, 1, MH=FALSE, 10^4, alpha=.1)
hist(x, breaks=seq(min(x), max(x), length=100), freq=FALSE, ylim=c(0, 0.7))
y <- seq(min(x), max(x), length=500)
z <- target(y) / Z
lines(y, z, col="red", lwd=2)
x <- MCMC(target, 1, MH=FALSE, 10^5, alpha=.1)
hist(x, breaks=seq(min(x), max(x), length=100), freq=FALSE, ylim=c(0, 0.7))
y <- seq(min(x), max(x), length=500)
z <- target(y) / Z
lines(y, z, col="red", lwd=2)
x <- MCMC(target, 1, MH=FALSE, 10^4, alpha=.2)
hist(x, breaks=seq(min(x), max(x), length=100), freq=FALSE, ylim=c(0, 0.7))
y <- seq(min(x), max(x), length=500)
z <- target(y) / Z
lines(y, z, col="red", lwd=2)
hist(x, breaks=seq(min(x), max(x), length=100), freq=FALSE, ylim=c(0, 0.7))
y <- seq(min(x), max(x), length=500)
z <- target(y) / Z
lines(y, z, col="red", lwd=2)
x <- MCMC(target, 1, MH=FALSE, 10^4, alpha=.3)
# One dimensional case, making nice pictures also.
hist(x, breaks=seq(min(x), max(x), length=100), freq=FALSE, ylim=c(0, 0.7))
y <- seq(min(x), max(x), length=500)
z <- target(y) / Z
lines(y, z, col="red", lwd=2)
x <- MCMC(target, 1, MH=FALSE, 10^4, alpha=.4)
# One dimensional case, making nice pictures also.
hist(x, breaks=seq(min(x), max(x), length=100), freq=FALSE, ylim=c(0, 0.7))
y <- seq(min(x), max(x), length=500)
z <- target(y) / Z
lines(y, z, col="red", lwd=2)
# Two dimensional toy example with a similar density. The points are plotted
# and a heat map is created which also shows the marginal densities.
x <- MCMC(target, c(1, 1), MH=TRUE, 10^4, alpha=3)
# Multivariate setting.
# Define the unnormalised density.
d <- 2
target <- function(x){
sin(x[1])^2 * sin(2 * x[2])^2 * dnorm(x[1]) * dnorm(x[2])
# sin(x)^2 * sin(2 * x)^2 * dnorm(x)
}
# Two dimensional toy example with a similar density. The points are plotted
# and a heat map is created which also shows the marginal densities.
x <- MCMC(target, c(1, 1), MH=TRUE, 10^4, alpha=3)
plot(t(x), pch=16, col='black', cex=0.5)
k <- kde2d(x[1, ], x[2, ], n=200, lims = c(-4, 4, -4, 4))
image(k, col=r, xlim=c(-4, 4), ylim=c(-4, 4))
y1 <- seq(min(x[2, ]), max(x[2, ]), length=500)
z1 <- sin(2 * y1)^2 * dnorm(y1) * 3
lines(z1 - rep(3.5, 500), y1, col="red", lwd=2)
y2 <- seq(min(x[1, ]), max(x[1, ]), length=500)
z2 <- sin(y2)^2 * dnorm(y2) * 3
lines(y2, z2 - rep(3.5, 500), col="red", lwd=2)
# Two dimensional toy example with a similar density. The points are plotted
# and a heat map is created which also shows the marginal densities.
x <- MCMC(target, c(0, 0), MH=0, 10^4, alpha=3)
# Two dimensional toy example with a similar density. The points are plotted
# and a heat map is created which also shows the marginal densities.
x <- MCMC(target, c(0, 0), MH=FALSE, 10^4, alpha=3)
# Two dimensional toy example with a similar density. The points are plotted
# and a heat map is created which also shows the marginal densities.
x <- MCMC(target, c(0, 0), MH=TRUE, 10^4, alpha=3)
# Two dimensional toy example with a similar density. The points are plotted
# and a heat map is created which also shows the marginal densities.
x <- MCMC(target, c(0, 0), MH=TRUE, 10^5, alpha=3)
plot(t(x), pch=16, col='black', cex=0.5)
k <- kde2d(x[1, ], x[2, ], n=200, lims = c(-4, 4, -4, 4))
image(k, col=r, xlim=c(-4, 4), ylim=c(-4, 4))
y1 <- seq(min(x[2, ]), max(x[2, ]), length=500)
z1 <- sin(2 * y1)^2 * dnorm(y1) * 3
lines(z1 - rep(3.5, 500), y1, col="red", lwd=2)
y2 <- seq(min(x[1, ]), max(x[1, ]), length=500)
z2 <- sin(y2)^2 * dnorm(y2) * 3
lines(y2, z2 - rep(3.5, 500), col="red", lwd=2)
# Two dimensional toy example with a similar density. The points are plotted
# and a heat map is created which also shows the marginal densities.
x <- MCMC(target, c(0, 0), MH=FALSE, 10^1, alpha=3)
# Implementing the MCMC method. The function needs the unnormalised density f,
# a starting value x0, sample size T whether it should be MH or Slice Sampling
# and the parameter alpha, which either specifies the variance of the proposal
# which is multivariate normal or the rate of the exponential random variable
# which defines the thickness of the random interval.
MCMC <- function (f, x0, T=10^3, MH=TRUE, alpha=1) {
d <- length(x0)
x <- matrix(rep(x0, T), d)
if (MH) {
for (t in 2:T) x[, t] <- Metropolis(x[, t-1], f, alpha)
}
else {
for (t in 2:T) x[, t] <- SliceSampling(x[, t-1], f, alpha)
}
return(x)
}
# Two dimensional toy example with a similar density. The points are plotted
# and a heat map is created which also shows the marginal densities.
x <- MCMC(target, c(0, 0), MH=TRUE, 10^3, alpha=3)
plot(t(x), pch=16, col='black', cex=0.5)
# Two dimensional toy example with a similar density. The points are plotted
# and a heat map is created which also shows the marginal densities.
x <- MCMC(target, c(0, 0), MH=TRUE, 10^4, alpha=3)
plot(t(x), pch=16, col='black', cex=0.5)
k <- kde2d(x[1, ], x[2, ], n=200, lims = c(-4, 4, -4, 4))
image(k, col=r, xlim=c(-4, 4), ylim=c(-4, 4))
y1 <- seq(min(x[2, ]), max(x[2, ]), length=500)
z1 <- sin(2 * y1)^2 * dnorm(y1) * 3
lines(z1 - rep(3.5, 500), y1, col="red", lwd=2)
y2 <- seq(min(x[1, ]), max(x[1, ]), length=500)
z2 <- sin(y2)^2 * dnorm(y2) * 3
lines(y2, z2 - rep(3.5, 500), col="red", lwd=2)
y1 <- seq(-4, 4, length=500)
z1 <- sin(2 * y1)^2 * dnorm(y1) * 3
lines(z1 - rep(3.5, 500), y1, col="red", lwd=2)
y2 <- seq(-4, 4, length=500)
z2 <- sin(y2)^2 * dnorm(y2) * 3
lines(y2, z2 - rep(3.5, 500), col="red", lwd=2)
k <- kde2d(x[1, ], x[2, ], n=200, lims = c(-4.3, 4, -4, 4))
image(k, col=r, xlim=c(-4, 4), ylim=c(-4, 4))
y1 <- seq(-4, 4, length=500)
z1 <- sin(2 * y1)^2 * dnorm(y1) * 3
lines(z1 - rep(3.5, 500), y1, col="red", lwd=2)
y2 <- seq(-4.3, 4, length=500)
z2 <- sin(y2)^2 * dnorm(y2) * 3
lines(y2, z2 - rep(3.5, 500), col="red", lwd=2)
image(k, col=r, xlim=c(-4, 4), ylim=c(-4.3, 4))
k <- kde2d(x[1, ], x[2, ], n=200, lims = c(-4.3, 4, -4.3, 4))
image(k, col=r, xlim=c(-4, 4), ylim=c(-4.3, 4))
image(k, col=r, xlim=c(-4.3, 4), ylim=c(-4, 4))
y1 <- seq(-4, 4, length=500)
z1 <- sin(2 * y1)^2 * dnorm(y1) * 3
lines(z1 - rep(3.8, 500), y1, col="red", lwd=2)
y2 <- seq(-4.3, 4, length=500)
z2 <- sin(y2)^2 * dnorm(y2) * 3
lines(y2, z2 - rep(3.5, 500), col="red", lwd=2)
# Calculating the acceptence rate for the MH algorithm; around 25% is desired
sum(x[-1] != x[1:(length(x) - 1)])/(T - 1)
# Calculating the acceptence rate for the MH algorithm; around 25% is desired
sum(x[-1] != x[1:(length(x) - 1)])/(T - 1)
# Two dimensional toy example with a similar density. The points are plotted
# and a heat map is created which also shows the marginal densities.
x <- MCMC(target, c(0, 0), MH=FALSE, 10^4, alpha=3)
# Two dimensional toy example with a similar density. The points are plotted
# and a heat map is created which also shows the marginal densities.
x <- MCMC(target, c(0, 0), MH=FALSE, 10^4, alpha=3)
RandomInterval(c(0, 0), 0.5, target)
x <- c(0, 0)
d <- length(x)
a <- rexp(1)  # rexp(length(x), rate=alpha)
# b <- rexp(1, rate=alpha)  # rexp(length(x), rate=alpha)
# We check both endpoints simultaneously to avoid the need of two loops.
while (target(x - rep(a, d)) >= target(x) * y || target(x + rep(a, d)) >= target(x) * y) {
a <- 2 * a
# b <- 2 * b
}
x <- c(0, 0)
d <- length(x)
a <- rexp(1)  # rexp(length(x), rate=alpha)
# b <- rexp(1, rate=alpha)  # rexp(length(x), rate=alpha)
# We check both endpoints simultaneously to avoid the need of two loops.
while (target(x - rep(a, d)) >= target(x) * y || target(x + rep(a, d)) >= target(x) * y) {
a <- 2 * a
# b <- 2 * b
}
target(x)
target(x - rep(a, d)) >= target(x) * y || target(x + rep(a, d)) >= target(x) * y
target(x - rep(a, d))
x - rep(a, d)
x - 1
# Now we turn towards slice sampling.
# Proposing a random interval that includes the slice. We use an exponential
# random variable to define the width of the interval.
RandomInterval <- function (x, y, f, alpha=1) {
# d <- length(x)
a <- rexp(1, rate=alpha)  # rexp(length(x), rate=alpha)
b <- rexp(1, rate=alpha)  # rexp(length(x), rate=alpha)
# We check both endpoints simultaneously to avoid the need of two loops.
while (f(x - a) >= f(x) * y || f(x + b) >= f(x) * y) {
a <- 2 * a
b <- 2 * b
}
# while (target(x + b) >= target(x) * y) {
#   b <- 2 * b
# }
return(matrix(c(x - a, x + b), d))
}
RandomInterval(c(0, 0), 0.5, target)
x <- c(0, 0)
d <- length(x)
a <- rexp(1)  # rexp(length(x), rate=alpha)
target(x - rep(a, d))
# Two dimensional toy example with a similar density. The points are plotted
# and a heat map is created which also shows the marginal densities.
x <- MCMC(target, c(1, 1), MH=FALSE, 10^4, alpha=3)
plot(t(x), pch=16, col='black', cex=0.5)
k <- kde2d(x[1, ], x[2, ], n=200, lims = c(-4.3, 4, -4, 4))
image(k, col=r, xlim=c(-4.3, 4), ylim=c(-4, 4))
y1 <- seq(-4, 4, length=500)
z1 <- sin(2 * y1)^2 * dnorm(y1) * 3
lines(z1 - rep(3.8, 500), y1, col="red", lwd=2)
y2 <- seq(-4.3, 4, length=500)
z2 <- sin(y2)^2 * dnorm(y2) * 3
lines(y2, z2 - rep(3.5, 500), col="red", lwd=2)
x <- MCMC(target, c(1, 1), MH=FALSE, 10^4, alpha=3)
plot(t(x), pch=16, col='black', cex=0.5)
k <- kde2d(x[1, ], x[2, ], n=200, lims = c(-4.3, 4, -4, 4))
image(k, col=r, xlim=c(-4.3, 4), ylim=c(-4, 4))
y1 <- seq(-4, 4, length=500)
z1 <- sin(2 * y1)^2 * dnorm(y1) * 3
lines(z1 - rep(3.8, 500), y1, col="red", lwd=2)
y2 <- seq(-4.3, 4, length=500)
z2 <- sin(y2)^2 * dnorm(y2) * 3
lines(y2, z2 - rep(3.5, 500), col="red", lwd=2)
# Implementing the MCMC method. The function needs the unnormalised density f,
# a starting value x0, sample size T whether it should be MH or Slice Sampling
# and the parameter alpha, which either specifies the variance of the proposal
# which is multivariate normal or the rate of the exponential random variable
# which defines the thickness of the random interval.
MCMC <- function (f, x0, T=10^3, MH=TRUE, alpha=1) {
d <- length(x0)
x <- matrix(rep(x0, T), d)
if (MH) {
for (t in 2:T) x[, t] <- Metropolis(x[, t-1], f, alpha)
}
else {
while (f(x0)==0) {
x0 <- mvrnorm(1, x0, diag(rep(alpha, d), d))
}
x[, 1] <- x0
for (t in 2:T) x[, t] <- SliceSampling(x[, t-1], f, alpha)
}
return(x)
}
x <- MCMC(target, c(1, 1), MH=FALSE, 10^4, alpha=3)
plot(t(x), pch=16, col='black', cex=0.5)
k <- kde2d(x[1, ], x[2, ], n=200, lims = c(-4.3, 4, -4, 4))
image(k, col=r, xlim=c(-4.3, 4), ylim=c(-4, 4))
y1 <- seq(-4, 4, length=500)
z1 <- sin(2 * y1)^2 * dnorm(y1) * 3
lines(z1 - rep(3.8, 500), y1, col="red", lwd=2)
y2 <- seq(-4.3, 4, length=500)
z2 <- sin(y2)^2 * dnorm(y2) * 3
lines(y2, z2 - rep(3.5, 500), col="red", lwd=2)
x <- MCMC(target, c(0, 0), MH=FALSE, 10^4, alpha=3)
plot(t(x), pch=16, col='black', cex=0.5)
k <- kde2d(x[1, ], x[2, ], n=200, lims = c(-4.3, 4, -4, 4))
image(k, col=r, xlim=c(-4.3, 4), ylim=c(-4, 4))
y1 <- seq(-4, 4, length=500)
z1 <- sin(2 * y1)^2 * dnorm(y1) * 3
lines(z1 - rep(3.8, 500), y1, col="red", lwd=2)
y2 <- seq(-4.3, 4, length=500)
z2 <- sin(y2)^2 * dnorm(y2) * 3
lines(y2, z2 - rep(3.5, 500), col="red", lwd=2)
# Now we turn towards slice sampling.
# Proposing a random interval that includes the slice. We use an exponential
# random variable to define the width of the interval.
RandomInterval <- function (x, y, f, alpha=1) {
# d <- length(x)
a <- rexp(1, rate=alpha)  # rexp(length(x), rate=alpha)
b <- rexp(1, rate=alpha)  # rexp(length(x), rate=alpha)
# We check both endpoints simultaneously to avoid the need of two loops.
while (f(x - a) >= f(x) * y)  {# || f(x + b) >= f(x) * y) {
a <- 2 * a
# b <- 2 * b
}
while (f(x + b) >= f(x) * y) {
b <- 2 * b
}
return(matrix(c(x - a, x + b), d))
}
x <- MCMC(target, c(0, 0), MH=FALSE, 10^4, alpha=3)
plot(t(x), pch=16, col='black', cex=0.5)
k <- kde2d(x[1, ], x[2, ], n=200, lims = c(-4.3, 4, -4, 4))
image(k, col=r, xlim=c(-4.3, 4), ylim=c(-4, 4))
y1 <- seq(-4, 4, length=500)
z1 <- sin(2 * y1)^2 * dnorm(y1) * 3
lines(z1 - rep(3.8, 500), y1, col="red", lwd=2)
y2 <- seq(-4.3, 4, length=500)
z2 <- sin(y2)^2 * dnorm(y2) * 3
lines(y2, z2 - rep(3.5, 500), col="red", lwd=2)
x <- MCMC(target, c(0, 0), MH=FALSE, 10^4, alpha=3)
plot(t(x), pch=16, col='black', cex=0.5)
k <- kde2d(x[1, ], x[2, ], n=200, lims = c(-4.3, 4, -4, 4))
image(k, col=r, xlim=c(-4.3, 4), ylim=c(-4, 4))
y1 <- seq(-4, 4, length=500)
z1 <- sin(2 * y1)^2 * dnorm(y1) * 3
lines(z1 - rep(3.8, 500), y1, col="red", lwd=2)
y2 <- seq(-4.3, 4, length=500)
z2 <- sin(y2)^2 * dnorm(y2) * 3
lines(y2, z2 - rep(3.5, 500), col="red", lwd=2)
# One dimensional case, making nice pictures also.
# Define the unnormalised density we want to sample from.
target <- function(x){
sin(x)^2 * sin(2 * x)^2 * dnorm(x)
}
library(cubature)
Z <- hcubature(target2, rep(-20, d), rep(20, d))[[1]]
x <- MCMC(target, 1, MH=FALSE, 10^4, alpha=.4)
hist(x, breaks=seq(min(x), max(x), length=100), freq=FALSE, ylim=c(0, 0.7))
y <- seq(min(x), max(x), length=500)
z <- target(y) / Z
lines(y, z, col="red", lwd=2)
# Load library for multidimensional integration to compute the normalisation
# constant.
library(cubature)
Z <- hcubature(target, rep(-20, d), rep(20, d))[[1]]
x <- MCMC(target, 1, MH=FALSE, 10^4, alpha=.4)
hist(x, breaks=seq(min(x), max(x), length=100), freq=FALSE, ylim=c(0, 0.7))
y <- seq(min(x), max(x), length=500)
z <- target(y) / Z
lines(y, z, col="red", lwd=2)
# One dimensional case, making nice pictures also.
# Define the unnormalised density we want to sample from.
target <- function(x){
sin(x)^2 * sin(2 * x)^2 * dnorm(x)
}
# Load library for multidimensional integration to compute the normalisation
# constant.
library(cubature)
Z <- hcubature(target, rep(-20, d), rep(20, d))[[1]]
x <- MCMC(target, 1, MH=FALSE, 10^4, alpha=.4)
x <- MCMC(target, 1, MH=TRUE, 10^4, alpha=.4)
hist(x, breaks=seq(min(x), max(x), length=100), freq=FALSE, ylim=c(0, 0.7))
y <- seq(min(x), max(x), length=500)
z <- target(y) / Z
lines(y, z, col="red", lwd=2)
Z
target <- function(x){
sin(x)^2 * sin(2 * x)^2 * dnorm(x)
}
Z <- hcubature(target, rep(-20, d), rep(20, d))[[1]]
Z
Z <- hcubature(target, -20, 20)[[1]]
Z
x <- MCMC(target, 1, MH=TRUE, 10^4, alpha=.4)
hist(x, breaks=seq(min(x), max(x), length=100), freq=FALSE, ylim=c(0, 0.7))
y <- seq(min(x), max(x), length=500)
z <- target(y) / Z
lines(y, z, col="red", lwd=2)
x <- MCMC(target, 1, MH=FALSE, 10^4, alpha=.4)
x <- MCMC(target, 1, MH=TRUE, 10^5, alpha=3)
hist(x, breaks=seq(min(x), max(x), length=100), freq=FALSE, ylim=c(0, 0.7))
y <- seq(min(x), max(x), length=500)
z <- target(y) / Z
lines(y, z, col="red", lwd=2)
x <- MCMC(target, 1, MH=TRUE, 10^4, alpha=3)
hist(x, breaks=seq(min(x), max(x), length=100), freq=FALSE, ylim=c(0, 0.7))
y <- seq(min(x), max(x), length=500)
z <- target(y) / Z
lines(y, z, col="red", lwd=2)
x <- MCMC(target, 1, MH=TRUE, 10^4, alpha=.3)
hist(x, breaks=seq(min(x), max(x), length=100), freq=FALSE, ylim=c(0, 0.7))
y <- seq(min(x), max(x), length=500)
z <- target(y) / Z
lines(y, z, col="red", lwd=2)
hist(x, breaks=seq(min(x), max(x), length=100), freq=FALSE, ylim=c(0, max(max(x),0.7)))
hist(x, breaks=seq(min(x), max(x), length=100), freq=FALSE, ylim=c(0, 0.7))
y <- seq(min(x), max(x), length=500)
z <- target(y) / Z
lines(y, z, col="red", lwd=2)
x <- MCMC(target, 1, MH=TRUE, 10^4, alpha=.1)
x <- MCMC(target, 1, MH=TRUE, 10^4, alpha=3)
hist(x, breaks=seq(min(x), max(x), length=100), freq=FALSE, ylim=c(0, 0.7))
y <- seq(min(x), max(x), length=500)
z <- target(y) / Z
lines(y, z, col="red", lwd=2)
x <- MCMC(target, 1, MH=FALSE, 10^4, alpha=3)
alpha <- 3
x <- 1
d <- length(x)
y <- runif(1)
c <- RandomInterval(x, y, target, alpha)
z <- runif(d, c[, 1], c[, 2])  # runif(1, -4, 4)
while (f(z) < f(x) * y) {
c <- RandomInterval(x, y, f, alpha)
z <- runif(d, c[, 1], c[, 2])
}
c
x <- MCMC(target, 1, MH=FALSE, 10, alpha=3)
hist(x, breaks=seq(min(x), max(x), length=100), freq=FALSE, ylim=c(0, 0.7))
x <- MCMC(target, 1, MH=FALSE, 10^2, alpha=3)
hist(x, breaks=seq(min(x), max(x), length=100), freq=FALSE, ylim=c(0, 0.7))
x <- MCMC(target, 1, MH=FALSE, 10^3, alpha=3)
hist(x, breaks=seq(min(x), max(x), length=100), freq=FALSE, ylim=c(0, 0.7))
x <- MCMC(target, 1, MH=FALSE, 10^4, alpha=3)
hist(x, breaks=seq(min(x), max(x), length=100), freq=FALSE, ylim=c(0, 0.7))
y <- seq(min(x), max(x), length=500)
z <- target(y) / Z
lines(y, z, col="red", lwd=2)
x <- MCMC(target, 1, MH=FALSE, 10^4, alpha=.3)
hist(x, breaks=seq(min(x), max(x), length=100), freq=FALSE, ylim=c(0, 0.7))
y <- seq(min(x), max(x), length=500)
z <- target(y) / Z
lines(y, z, col="red", lwd=2)
x <- MCMC(target, 1, MH=FALSE, 10^4, alpha=.1)
hist(x, breaks=seq(min(x), max(x), length=100), freq=FALSE, ylim=c(0, 0.7))
y <- seq(min(x), max(x), length=500)
z <- target(y) / Z
lines(y, z, col="red", lwd=2)
x <- MCMC(target, 1, MH=FALSE, 10^4, alpha=.2)
hist(x, breaks=seq(min(x), max(x), length=100), freq=FALSE, ylim=c(0, 0.7))
y <- seq(min(x), max(x), length=500)
z <- target(y) / Z
lines(y, z, col="red", lwd=2)
x <- MCMC(target, 1, MH=FALSE, 10^4, alpha=.1)
hist(x, breaks=seq(min(x), max(x), length=100), freq=FALSE, ylim=c(0, 0.7))
y <- seq(min(x), max(x), length=500)
z <- target(y) / Z
lines(y, z, col="red", lwd=2)
x <- MCMC(target, 1, MH=FALSE, 10^4, alpha=.3)
hist(x, breaks=seq(min(x), max(x), length=100), freq=FALSE, ylim=c(0, 0.7))
y <- seq(min(x), max(x), length=500)
z <- target(y) / Z
lines(y, z, col="red", lwd=2)
x <- MCMC(target, 1, MH=FALSE, 10^4, alpha=.1)
hist(x, breaks=seq(min(x), max(x), length=100), freq=FALSE, ylim=c(0, 0.7))
y <- seq(min(x), max(x), length=500)
z <- target(y) / Z
lines(y, z, col="red", lwd=2)
x <- MCMC(target, 1, MH=FALSE, 10^5, alpha=.1)
hist(x, breaks=seq(min(x), max(x), length=100), freq=FALSE, ylim=c(0, 0.7))
y <- seq(min(x), max(x), length=500)
z <- target(y) / Z
lines(y, z, col="red", lwd=2)
# Two dimensional toy example with a similar density. The points are plotted
# and a heat map is created which also shows the marginal densities.
target2 <- function(x){
sin(x[1])^2 * sin(2 * x[2])^2 * dnorm(x[1]) * dnorm(x[2])
}
x <- MCMC(target2, c(0, 0), MH=FALSE, 10^4, alpha=0.3)
x <- MCMC(target2, c(1, 1), MH=FALSE, 10^4, alpha=0.3)
x <- MCMC(target2, c(1, 1), MH=FALSE, 10^3, alpha=0.3)
x <- MCMC(target2, c(1, 1), MH=TRUE, 10^3, alpha=0.3)
plot(t(x), pch=16, col='black', cex=0.5)
x <- MCMC(target2, c(1, 1), MH=TRUE, 10^4, alpha=0.3)
plot(t(x), pch=16, col='black', cex=0.5)
k <- kde2d(x[1, ], x[2, ], n=200, lims = c(-4.3, 4, -4, 4))
image(k, col=r, xlim=c(-4.3, 4), ylim=c(-4, 4))
y1 <- seq(-4, 4, length=500)
z1 <- sin(2 * y1)^2 * dnorm(y1) * 3
lines(z1 - rep(3.8, 500), y1, col="red", lwd=2)
y2 <- seq(-4.3, 4, length=500)
z2 <- sin(y2)^2 * dnorm(y2) * 3
lines(y2, z2 - rep(3.5, 500), col="red", lwd=2)
x <- MCMC(target2, c(1, 1), MH=FALSE, 10^4, alpha=0.3)
x <- MCMC(target2, c(1, 1), MH=FALSE, 10^2, alpha=0.3)
x <- MCMC(target2, c(1, 1), MH=FALSE, 10, alpha=0.3)
x <- MCMC(target2, c(1, 1), MH=FALSE, 1, alpha=0.3)
# Doing a single slice sample.
SliceSampling <- function (x, f, alpha=1) {
d <- length(x)
y <- runif(1)
c <- RandomInterval(x, y, f, alpha)
z <- runif(d, c[, 1], c[, 2])  # runif(1, -4, 4)
while (f(z) < f(x) * y) {
# c <- RandomInterval(x, y, f, alpha)
z <- runif(d, c[, 1], c[, 2])
}
return(z)
}
x <- MCMC(target2, c(1, 1), MH=FALSE, 1, alpha=0.3)
x <- MCMC(target, 1, MH=FALSE, 10^5, alpha=.1)
x <- MCMC(target, 1, MH=FALSE, 10^4, alpha=.1)
hist(x, breaks=seq(min(x), max(x), length=100), freq=FALSE, ylim=c(0, 0.7))
y <- seq(min(x), max(x), length=500)
z <- target(y) / Z
lines(y, z, col="red", lwd=2)
x <- MCMC(target2, c(1, 1), MH=FALSE, 1, alpha=3)
x <- c(1, 1)
y <- runif(1)
RandomInterval(x, y, target)
RandomInterval(x, y, target2)
# Now we turn towards slice sampling. Proposing a random interval that includes
# the slice. We use an exponential random variable to define the width of the
# interval.
RandomInterval <- function (x, y, f, alpha=1) {
# We make the interval the same length in every dimension.
a <- rexp(1, rate=alpha)  # rexp(length(x), rate=alpha)
b <- rexp(1, rate=alpha)  # rexp(length(x), rate=alpha)
# One can check both endpoints simultaneously to avoid the need of two loops.
while (f(x - a) >= f(x) * y)  {# || f(x + b) >= f(x) * y) {
a <- 2 * a
# b <- 2 * b
}
while (f(x + b) >= f(x) * y) {
b <- 2 * b
}
return(matrix(c(x - a, x + b), length(x)))
}
RandomInterval(x, y, target2)
x <- MCMC(target2, c(1, 1), MH=FALSE, 1, alpha=3)
x <- MCMC(target2, c(1, 1), MH=FALSE, 10^3, alpha=3)
plot(t(x), pch=16, col='black', cex=0.5)
x <- MCMC(target2, c(1, 1), MH=FALSE, 10, alpha=3)
plot(t(x), pch=16, col='black', cex=0.5)
x <- MCMC(target2, c(1, 1), MH=FALSE, 10^2, alpha=3)
plot(t(x), pch=16, col='black', cex=0.5)
x <- MCMC(target2, c(1, 1), MH=FALSE, 10^3, alpha=3)
plot(t(x), pch=16, col='black', cex=0.5)
x <- MCMC(target2, c(1, 1), MH=FALSE, 10^4, alpha=3)
plot(t(x), pch=16, col='black', cex=0.5)
k <- kde2d(x[1, ], x[2, ], n=200, lims = c(-4.3, 4, -4, 4))
image(k, col=r, xlim=c(-4.3, 4), ylim=c(-4, 4))
y1 <- seq(-4, 4, length=500)
z1 <- sin(2 * y1)^2 * dnorm(y1) * 3
lines(z1 - rep(3.8, 500), y1, col="red", lwd=2)
y2 <- seq(-4.3, 4, length=500)
z2 <- sin(y2)^2 * dnorm(y2) * 3
lines(y2, z2 - rep(3.5, 500), col="red", lwd=2)
