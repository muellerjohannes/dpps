RandomInterval(1, 0.3)
target <- function(x){
sin(x)^2 * sin(2 * x)^2 * dnorm(x)
}
# Proposing a random interval that includes the slice.
RandomInterval <- function (x, y, alpha=1) {
a <- rexp(1, rate=alpha)
b <- rexp(1, rate=alpha)
while (target(x - a) < target(x) * y) {
a <- 2 * a
}
while (target(x + b) < target(x) * y) {
b <- 2 * b
}
return(c(x - a, x + b))
}
RandomInterval(1, 0.3)
RandomInterval(1, 0.3)
RandomInterval(2, 0.3)
RandomInterval(2, 0.3)
RandomInterval(2, 0.03)
RandomInterval(2, 0.03)
a <- rexp(1)
b <- rexp(1)
target(x + b) < target(x) * y
target(2 + b) < target(2) * 0.03
target(2 + b) < target(2) * 0.03
target(2 + rexp(1)) < target(2) * 0.03
target(2 + rexp(1)) < target(2) * 0.03
target(2 + rexp(1)) < target(2) * 0.03
target(2 + rexp(1)) < target(2) * 0.03
target(2 + rexp(1)) < target(2) * 0.03
target(2 + rexp(1)) < target(2) * 0.03
target(2 + rexp(1)) < target(2) * 0.09
target(2 + rexp(1)) < target(2) * 0.09
target(2 + rexp(1)) < target(2) * 0.09
target(2 + rexp(1)) < target(2) * 0.09
target(2 + rexp(1)) < target(2) * 0.09
target(2 + rexp(1)) < target(2) * 0.09
target(2 + rexp(1)) < target(2) * 0.09
# Proposing a random interval that includes the slice.
RandomInterval <- function (x, y, alpha=1) {
a <- rexp(1, rate=alpha)
b <- rexp(1, rate=alpha)
while (target(x - a) < (target(x) * y)) {
a <- 2 * a
}
while (target(x + b) < (target(x) * y)) {
b <- 2 * b
}
return(c(x - a, x + b))
}
RandomInterval(2, 0.03)
target(2)
target(2)
RandomInterval(2, 0.03)
RandomInterval(2, 0.03)
RandomInterval(2, 0.03)
RandomInterval(2, 0.03)
b <- rexp(1)
x <- 2
y <- 0.03
while (target(x + b) < target(x) * y) {
b <- 2 * b
}
b
b
b <- rexp(1)
b
x <- 2
y <- 0.03
while (target(x + b) < target(x) * y) {
b <- 2 * b
}
target(x + b)
(x + b)
x
b
# Proposing a random interval that includes the slice.
RandomInterval <- function (x, y, alpha=1) {
a <- rexp(1, rate=alpha)
b <- rexp(1, rate=alpha)
while (target(x - a) >= target(x) * y) {
a <- 2 * a
}
while (target(x + b) >= target(x) * y) {
b <- 2 * b
}
return(c(x - a, x + b))
}
RandomInterval(2, 0.03)
RandomInterval(2, 0.03)
RandomInterval(2, 0.03)
RandomInterval(2, 0.03)
RandomInterval(2, 0.03)
RandomInterval(2, 0.03)
RandomInterval(2, 0.03, 4)
RandomInterval(2, 0.03, 4)
RandomInterval(2, 0.03, 4)
RandomInterval(2, 0.03, 4)
RandomInterval(2, 0.03, 4)
RandomInterval(2, 0.03, 4)
RandomInterval(2, 0.03, 8)
RandomInterval(2, 0.03, 8)
RandomInterval(2, 0.03, 8)
RandomInterval(2, 0.03, 8)
RandomInterval(2, 0.03, 8)
RandomInterval(2, 0.03, 8)
RandomInterval(2, 0.03, 8)
RandomInterval(2, 0.03, 8)
RandomInterval(2, 0.03, 8)
RandomInterval(2, 0.03, 8)
RandomInterval(2, 0.03, 8)
RandomInterval(2, 0.03, 8)
c <- RandomInterval(2, 0.03, 8)
c
c[1]
c[2]
# Doing the slice sampling
SliceSampling <- function (x, alpha=1) {
y <- runif(1)
c <- RandomInterval(x, y, alpha)
z <- runif(1, c[1], c[2])  # runif(1, -4, 4)
while (target(z) < target(x) * y) {
z <- runif(1, -4, 4)
}
return(z)
}
T <- 10^3
x <- rep(3.14, T)
for (t in 2:T) x[t] <- SliceSampling(x[t-1])
hist(x, breaks=seq(min(x), max(x), length=100), freq=FALSE)
y <- seq(min(x), max(x), length=500)
z <- f(y) / Z
lines(y, z, col="red", lwd=2)
T <- 10^4
x <- rep(3.14, T)
for (t in 2:T) x[t] <- SliceSampling(x[t-1])
hist(x, breaks=seq(min(x), max(x), length=100), freq=FALSE)
y <- seq(min(x), max(x), length=500)
z <- f(y) / Z
lines(y, z, col="red", lwd=2)
for (t in 2:T) x[t] <- SliceSampling(x[t-1], 3)
hist(x, breaks=seq(min(x), max(x), length=100), freq=FALSE)
y <- seq(min(x), max(x), length=500)
z <- f(y) / Z
lines(y, z, col="red", lwd=2)
for (t in 2:T) x[t] <- SliceSampling(x[t-1], 6)
hist(x, breaks=seq(min(x), max(x), length=100), freq=FALSE)
y <- seq(min(x), max(x), length=500)
z <- f(y) / Z
lines(y, z, col="red", lwd=2)
for (t in 2:T) x[t] <- SliceSampling(x[t-1], 10)
hist(x, breaks=seq(min(x), max(x), length=100), freq=FALSE)
y <- seq(min(x), max(x), length=500)
z <- f(y) / Z
lines(y, z, col="red", lwd=2)
for (t in 2:T) x[t] <- SliceSampling(x[t-1], 0.1)
hist(x, breaks=seq(min(x), max(x), length=100), freq=FALSE)
y <- seq(min(x), max(x), length=500)
z <- f(y) / Z
lines(y, z, col="red", lwd=2)
for (t in 2:T) x[t] <- SliceSampling(x[t-1], 2)
hist(x, breaks=seq(min(x), max(x), length=100), freq=FALSE)
y <- seq(min(x), max(x), length=500)
z <- f(y) / Z
lines(y, z, col="red", lwd=2)
for (t in 2:T) x[t] <- SliceSampling(x[t-1], 2)
hist(x, breaks=seq(min(x), max(x), length=100), freq=FALSE)
y <- seq(min(x), max(x), length=500)
z <- f(y) / Z
lines(y, z, col="red", lwd=2)
for (t in 2:T) x[t] <- SliceSampling(x[t-1], 2)
hist(x, breaks=seq(min(x), max(x), length=100), freq=FALSE)
y <- seq(min(x), max(x), length=500)
z <- f(y) / Z
lines(y, z, col="red", lwd=2)
# Computation of the actual partition function
target <- function(x){
sin(x)^2 * sin(2 * x)^2 * dnorm(x)
}
Z <- integrate(target, -100, 100)[[1]]
T <- 10^4
x <- rep(3.14, T)
for (t in 2:T) x[t] <- SliceSampling(x[t-1], 2)
hist(x, breaks=seq(min(x), max(x), length=100), freq=FALSE)
y <- seq(min(x), max(x), length=500)
z <- target(y) / Z
lines(y, z, col="red", lwd=2)
T <- 10^5
x <- rep(3.14, T)
for (t in 2:T) x[t] <- SliceSampling(x[t-1], 2)
hist(x, breaks=seq(min(x), max(x), length=100), freq=FALSE)
y <- seq(min(x), max(x), length=500)
z <- target(y) / Z
lines(y, z, col="red", lwd=2)
T <- 10^3
x <- rep(3.14, T)
for (t in 2:T) x[t] <- SliceSampling(x[t-1], 2)
hist(x, breaks=seq(min(x), max(x), length=100), freq=FALSE)
y <- seq(min(x), max(x), length=500)
z <- target(y) / Z
lines(y, z, col="red", lwd=2)
T <- 10^4
x <- rep(3.14, T)
for (t in 2:T) x[t] <- SliceSampling(x[t-1], 2)
hist(x, breaks=seq(min(x), max(x), length=100), freq=FALSE)
y <- seq(min(x), max(x), length=500)
T <- 10^4
x <- rep(3.14, T)
for (t in 2:T) x[t] <- SliceSampling(x[t-1], 2)
hist(x, breaks=seq(min(x), max(x), length=100), freq=FALSE)
y <- seq(min(x), max(x), length=500)
z <- target(y) / Z
lines(y, z, col="red", lwd=2)
T <- 10^4
x <- rep(3.14, T)
for (t in 2:T) x[t] <- SliceSampling(x[t-1], 2)
hist(x, breaks=seq(min(x), max(x), length=100), freq=FALSE)
y <- seq(min(x), max(x), length=500)
z <- target(y) / Z
lines(y, z, col="red", lwd=2)
T <- 10^4
x <- rep(3.14, T)
for (t in 2:T) x[t] <- SliceSampling(x[t-1], 2)
hist(x, breaks=seq(min(x), max(x), length=100), freq=FALSE)
y <- seq(min(x), max(x), length=500)
z <- target(y) / Z
lines(y, z, col="red", lwd=2)
TRUE + FAlSE
TRUE + FALSE
FALSE + FALSE
FALSE & TRUE
TRUE & TRUE
TRUE or TRUE
TRUE || TRUE
FALSE || TRUE
# Now we turn towards slice sampling.
# Proposing a random interval that includes the slice.
RandomInterval <- function (x, y, alpha=1) {
a <- rexp(1, rate=alpha)
b <- rexp(1, rate=alpha)
# We check both endpoints simultaneously to avoid the need of two loops.
while (target(x - a) >= target(x) * y || target(x + b) >= target(x) * y) {
a <- 2 * a
}
# while (target(x + b) >= target(x) * y) {
#   b <- 2 * b
# }
return(c(x - a, x + b))
}
# Computation of the actual partition function.
target <- function(x){
sin(x)^2 * sin(2 * x)^2 * dnorm(x)
}
Z <- integrate(target, -100, 100)[[1]]
# Now we turn towards slice sampling.
# Proposing a random interval that includes the slice.
RandomInterval <- function (x, y, alpha=1) {
a <- rexp(1, rate=alpha)
b <- rexp(1, rate=alpha)
# We check both endpoints simultaneously to avoid the need of two loops.
while (target(x - a) >= target(x) * y || target(x + b) >= target(x) * y) {
a <- 2 * a
}
# while (target(x + b) >= target(x) * y) {
#   b <- 2 * b
# }
return(c(x - a, x + b))
}
# Doing a single slice sample.
SliceSampling <- function (x, alpha=1) {
y <- runif(1)
c <- RandomInterval(x, y, alpha)
z <- runif(1, c[1], c[2])  # runif(1, -4, 4)
while (target(z) < target(x) * y) {
z <- runif(1, -4, 4)
}
return(z)
}
T <- 10^4
x <- rep(3.14, T)
for (t in 2:T) x[t] <- SliceSampling(x[t-1], 2)
# Now we turn towards slice sampling.
# Proposing a random interval that includes the slice.
RandomInterval <- function (x, y, alpha=1) {
a <- rexp(1, rate=alpha)
b <- rexp(1, rate=alpha)
# We check both endpoints simultaneously to avoid the need of two loops.
while (target(x - a) >= target(x) * y || target(x + b) >= target(x) * y) {
a <- 2 * a
b <- 2 * b
}
# while (target(x + b) >= target(x) * y) {
#   b <- 2 * b
# }
return(c(x - a, x + b))
}
T <- 10^4
x <- rep(3.14, T)
for (t in 2:T) x[t] <- SliceSampling(x[t-1], 2)
hist(x, breaks=seq(min(x), max(x), length=100), freq=FALSE)
y <- seq(min(x), max(x), length=500)
z <- target(y) / Z
lines(y, z, col="red", lwd=2)
T <- 10^5
x <- rep(3.14, T)
for (t in 2:T) x[t] <- SliceSampling(x[t-1], 2)
hist(x, breaks=seq(min(x), max(x), length=100), freq=FALSE)
y <- seq(min(x), max(x), length=500)
z <- target(y) / Z
lines(y, z, col="red", lwd=2)
# Implement the propose and reject step.
metropolis <- function(x, alpha=1){
y <- rnorm(1, mean=x, sd=alpha)  # runif(1, x - alpha, x + alpha)
if (runif(1) > target(y) / target(x)) y <- x
return(y)
}
T <- 10^5
x <- rep(3.14, T)
for (t in 2:T) x[t] <- metropolis(x[t-1], 3)
hist(x, breaks=seq(min(x), max(x), length=100), freq=FALSE)
y <- seq(min(x), max(x), length=500)
z <- target(y) / Z
lines(y, z, col="red", lwd=2)
T <- 10^5
x <- rep(3.14, T)
for (t in 2:T) x[t] <- metropolis(x[t-1], 3)
hist(x, breaks=seq(min(x), max(x), length=100), freq=FALSE)
y <- seq(min(x), max(x), length=500)
z <- target(y) / Z
lines(y, z, col="red", lwd=2)
T <- 10^4
x <- rep(3.14, T)
for (t in 2:T) x[t] <- SliceSampling(x[t-1], 2)
hist(x, breaks=seq(min(x), max(x), length=100), freq=FALSE)
y <- seq(min(x), max(x), length=500)
z <- target(y) / Z
lines(y, z, col="red", lwd=2)
T <- 10^4
x <- rep(3.14, T)
for (t in 2:T) x[t] <- SliceSampling(x[t-1], 2)
hist(x, breaks=seq(min(x), max(x), length=100), freq=FALSE)
y <- seq(min(x), max(x), length=500)
z <- target(y) / Z
lines(y, z, col="red", lwd=2)
T <- 10^4
x <- rep(3.14, T)
for (t in 2:T) x[t] <- SliceSampling(x[t-1], 2)
hist(x, breaks=seq(min(x), max(x), length=100), freq=FALSE)
y <- seq(min(x), max(x), length=500)
z <- target(y) / Z
lines(y, z, col="red", lwd=2)
T <- 10^4
x <- rep(3.14, T)
for (t in 2:T) x[t] <- SliceSampling(x[t-1], 2)
hist(x, breaks=seq(min(x), max(x), length=100), freq=FALSE)
y <- seq(min(x), max(x), length=500)
z <- target(y) / Z
lines(y, z, col="red", lwd=2)
1:10[1]
x <- 1:10
x[1]
x[-1]
x[-2]
T <- 10^4
x <- rep(3.14, T)
for (t in 2:T) x[t] <- SliceSampling(x[t-1], 2)
# Throwing away the burn in period.
x <- x[T/10:T]
hist(x, breaks=seq(min(x), max(x), length=100), freq=FALSE)
y <- seq(min(x), max(x), length=500)
z <- target(y) / Z
lines(y, z, col="red", lwd=2)
# Testing the MCMC method including a histogram and the real density.
# the MH algorithm and SliceSampling can simple be exchanged.
T <- 10^4
x <- rep(3.14, T)
for (t in 2:T) x[t] <- SliceSampling(x[t-1], 2)
# Throwing away the burn in period.
x <- x[T/10:T]
hist(x, breaks=seq(min(x), max(x), length=100), freq=FALSE)
y <- seq(min(x), max(x), length=500)
z <- target(y) / Z
lines(y, z, col="red", lwd=2)
# Testing the MCMC method including a histogram and the real density.
# the MH algorithm and SliceSampling can simple be exchanged.
T <- 10^4
x <- rep(3.14, T)
for (t in 2:T) x[t] <- SliceSampling(x[t-1], 2)
# Throwing away the burn in period.
# x <- x[T/10:T]
hist(x, breaks=seq(min(x), max(x), length=100), freq=FALSE)
# Throwing away the burn in period.
x <- x[1:T/10]
hist(x, breaks=seq(min(x), max(x), length=100), freq=FALSE)
# Testing the MCMC method including a histogram and the real density.
# the MH algorithm and SliceSampling can simple be exchanged.
T <- 10^4
x <- rep(3.14, T)
for (t in 2:T) x[t] <- SliceSampling(x[t-1], 2)
# Throwing away the burn in period.
# x <- x[1:T/10]
hist(x, breaks=seq(min(x), max(x), length=100), freq=FALSE)
y <- seq(min(x), max(x), length=500)
z <- target(y) / Z
lines(y, z, col="red", lwd=2)
# Testing the MCMC method including a histogram and the real density.
# the MH algorithm and SliceSampling can simple be exchanged.
T <- 10^4
x <- rep(3.14, T)
for (t in 2:T) x[t] <- metropolis(x[t-1], 2)
# Throwing away the burn in period.
x <- x[1:T/10]
hist(x, breaks=seq(min(x), max(x), length=100), freq=FALSE)
y <- seq(min(x), max(x), length=500)
z <- target(y) / Z
lines(y, z, col="red", lwd=2)
T <- 10^5
x <- rep(3.14, T)
for (t in 2:T) x[t] <- metropolis(x[t-1], 2)
# Throwing away the burn in period.
x <- x[1:T/10]
hist(x, breaks=seq(min(x), max(x), length=100), freq=FALSE)
y <- seq(min(x), max(x), length=500)
z <- target(y) / Z
lines(y, z, col="red", lwd=2)
T <- 10^6
x <- rep(3.14, T)
for (t in 2:T) x[t] <- metropolis(x[t-1], 2)
# Throwing away the burn in period.
x <- x[1:T/10]
hist(x, breaks=seq(min(x), max(x), length=100), freq=FALSE)
y <- seq(min(x), max(x), length=500)
z <- target(y) / Z
lines(y, z, col="red", lwd=2)
T <- 10^5
x <- rep(3.14, T)
for (t in 2:T) x[t] <- metropolis(x[t-1], 2)
# Throwing away the burn in period.
x <- x[1:T/10]
hist(x, breaks=seq(min(x), max(x), length=100), freq=FALSE)
y <- seq(min(x), max(x), length=500)
z <- target(y) / Z
lines(y, z, col="red", lwd=2)
T <- 10^5
x <- rep(3.14, T)
for (t in 2:T) x[t] <- metropolis(x[t-1], 2)
# Throwing away the burn in period.
# x <- x[1:T/10]
hist(x, breaks=seq(min(x), max(x), length=100), freq=FALSE)
y <- seq(min(x), max(x), length=500)
z <- target(y) / Z
lines(y, z, col="red", lwd=2)
dnorm(c(1, 2))
mvrnorm(1)
install.packages("mvtnorm")
mvrnorm(1)
mvrnorm(1, c(0, 0))
install.packages("mvtnorm")
# Multivariate setting.
target2 <- function(x){
dnorm(x[1]) * dnorm(x[2])
}
# Implement the propose and reject step.
metropolis <- function(x, alpha=1){
y1 <- rnorm(1, mean=x[1], sd=alpha)  # runif(1, x - alpha, x + alpha)
y2 <- rnorm(1, mean=x[2], sd=alpha)
y <- c(y1, y2)
if (runif(1) > target(y) / target(x)) y <- x
return(y)
}
T <- 10^4
x <- rep(3.14, T)
for (t in 2:T) x[t] <- metropolis(x[t-1], 2)
library(hexbin)
install.packages("hexbin")
library(MASS)
x
# Implement the propose and reject step.
metropolis2 <- function(x, alpha=1){
y1 <- rnorm(1, mean=x[1], sd=alpha)  # runif(1, x - alpha, x + alpha)
y2 <- rnorm(1, mean=x[2], sd=alpha)
y <- c(y1, y2)
if (runif(1) > target(y) / target(x)) y <- x
return(y)
}
x <- matrix(rep(3.14, 2 * T), 2)
x
x[1]
x[1, ]
x[, 1]
T <- 10^4
x <- matrix(rep(3.14, 2 * T), 2)
for (t in 2:T) x[, t] <- metropolis2(x[, t-1], 2)
hist(x, breaks=seq(min(x), max(x), length=100), freq=FALSE)
T <- 10^4
x <- matrix(rep(3.14, 2 * T), 2)
for (t in 2:T) x[, t] <- metropolis2(x[, t-1], .2)
hist(x, breaks=seq(min(x), max(x), length=100), freq=FALSE)
T <- 10^5
x <- matrix(rep(3.14, 2 * T), 2)
for (t in 2:T) x[, t] <- metropolis2(x[, t-1], .2)
hist(x, breaks=seq(min(x), max(x), length=100), freq=FALSE)
T <- 10^5
x <- matrix(rep(.2, 2 * T), 2)
for (t in 2:T) x[, t] <- metropolis2(x[, t-1], .2)
hist(x, breaks=seq(min(x), max(x), length=100), freq=FALSE)
k <- kde2d(x[1, ], x[2, ])
image(k, col=r)
image(k, col="red")
image(k)
